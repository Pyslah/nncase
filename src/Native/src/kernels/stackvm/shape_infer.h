/* This file is generated by tools/stackvm_gen/IsaGen at 2022/5/14 下午6:47:34
* +08:00.
*
* Copyright 2019-2021 Canaan Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#pragma once
#include <nncase/kernels/kernel_context.h>
#include <nncase/runtime/datatypes.h>
#include <nncase/runtime/error.h>
#include <nncase/runtime/result.h>
#include <nncase/runtime/stackvm/opcode.h>
#include <nncase/tensor.h>
#include <nncase/value.h>

BEGIN_NS_NNCASE_KERNELS_MODULE(stackvm)

dims_t gather_infer_shape(const dims_t& in_shape, const dims_t& index_shape, int axis) {
    auto new_shape = in_shape;
    new_shape.erase(new_shape.begin() + axis);
    new_shape.insert(new_shape.begin() + axis, index_shape.begin(), index_shape.end());
    return new_shape;
}

dims_t gather_nd_infer_shape(const dims_t& in_shape, const dims_t& index_shape, size_t batch_dims) {
    auto new_shape = index_shape;
    new_shape.pop_back();
    new_shape.insert(new_shape.end(), in_shape.begin() + index_shape.back() + batch_dims, in_shape.end());
    if(new_shape.empty())
    {
        new_shape.push_back(1);
    }
    return new_shape;
}

dims_t concat_infer_shape(std::vector<dims_t> shapes, int axis) {
    auto new_shape = shapes[0];
    new_shape[axis] = std::accumulate(shapes.begin(), shapes.end(), 0,
                                      [&](auto sum, auto in_shape) -> int {
        return sum + in_shape[axis];
    });
    return new_shape;
}
END_NS_NNCASE_KERNELS_MODULE